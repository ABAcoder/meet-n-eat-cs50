Meet&Eat 
Website Design
Registration:
To register for an account, a user must fill out a form containing a valid Harvard email address. We do this to make sure our users are Harvard students. We check email addresses with Regular Expressions and we verify that a person has access to said account by sending the email address a randomly generated pin that is not equal to zero. In order to ensure that a person cannot log into an account, we prohibit any account with a temporary code not equal to zero from being able to access their account. Once someone has inputted a correct pin number, their temporary code is changed to zero and they will be able to access their account. If someone messed up their email or if they did not receive an email, they can fill out the bottom half of the “Registered.html” form that will allow them to essentially change their email and get their code resent to them. We accomplish this by receiving input from the appropriate fields and querying for the user’s temporary code.

Login:
Our Login is a standard login as seen in Finance, but we can recover lost usernames and passwords. Users can recover their username by getting it emailed to them by inputting their email address. They can also change their password if they have forgotten by utilizing the same temporary code system as mentioned in registration. This allows users to access forgotten credentials in a safe manner.

Homepage:
Much like finance, our homepage displays the meetups that were booked by the user. We have this feature to allow easy access to a user’s meetup “schedule.” Implementation requires a for loop in Jinja that prints out a table retrieved from our SQL tables queue and users.

Book/Hours/Cancel:
The date input for our booking mechanism makes it easy for someone to visualize what day they are booking. The meal choices from a select input allow us to restrict the times they can choose from realistically based on Annenberg hours. This is reflected with “Hours.html” which receives direct input from the submission of information from the booking page. Increments of 15 minutes in the select inputs are put in place to not overwhelm the user with potential times and streamline the matching process as seen in the match algorithm. These 15 minute increments are made possible by a Jinja for loop. Our cancelling interface mirrors the homepage, which allows the users to visualize and exactly choose what meetup they want to cancel. Implementation was based off the homepage with unique buttons to the side of every row in the table.

Profile:
In profile, users can see their information besides passwords, which are obviously sensitive. This is achieved by receiving proper information from the users SQL table and rendering it with Jinja. They can change their first and last name by submitting the form in the Profile page with relevant information. Users are not allowed to change anything else because other data points like usernames and emails must be unique and constant in order for the website to run efficiently.    


Implementation of the Match Algorithm

The match algorithm, the function “match()” in match.py, searches through the database “queue” in meet_n_eat.db to identify and match bookings with overlapping times, and calculates the actual start and end times of these matched meetings based on user availability. For instance, if user1 makes a booking for breakfast on 12/07/2021 with availability from 8:15 a.m. - 9:30 a.m. and user2 makes a booking for breakfast on 12/07/2021 with availability from 8:45 a.m. - 10:00 a.m, then match() will match the two users’ bookings and generate a meeting on 12/07/2021 from 8:45 a.m. to 9:30 a.m. Specifically, the function updates the “queue” table so that these matched bookings have status ‘MATCHED,’ and the times are updated to the calculated start and end times of the meetings (i.e. 8:45 a.m. and 9:30 a.m., respectively, in the above example). 

The function first queries the SQL table ‘queue’ (which includes information about each booking) in meet_n_eat.db, such that the status of each booking is ‘PENDING’ and so that it is ordered in chronological order by start time. By selecting bookings with status ‘PENDING,’ the function ensures that only unmatched bookings are matched and no previous matches are overridden. Our choice of ordering the query by chronological order of start time reflects a design choice for prioritizing bookings with times closer to the present in the matching process; this is to ensure that those only available for a meal in the near future are still promptly matched. For instance, if it is 8:00 a.m., then our design makes it so that someone who made a booking from 8:15 a.m. will be matched before someone who made a booking at 9:00 a.m. so that the first user is matched before their available time ends. 

In order to determine which bookings are matched, the function generates the list “pot_times” which stores the set of all available times for each booking. For instance, if a certain booking has start time 11:45 a.m. and end time 1:00 p.m., then the element in list “pot_times” corresponding to the index of the particular booking will store all times that the user is available for in this time range; specifically, it will be stored in increments of 15 minutes, in this instance the elements of “pot_times” being 11:45 a.m., 12:00 p.m., 12:15 p.m., 12:30 p.m., 12:45 p.m., 1:00 p.m. The reason for storing times in 15 minute increments is outlined in the section ‘15 Minute Increments.’

Once ‘pot_times’ is populated with the potential times for each booking, then each entry in ‘pot_times’ (the set of potential times for a certain booking) is compared to obtain the intersection of these entries, generating a list of times named “cap_times.” Since the bookings are already in chronological order since the extracted query is ordered by start time, once a non-trivial list is generated the match is confirmed (explanation below). The algorithm obtains the id of the queue (‘q_id’) by storing the indices of the ‘pot_times’ once the match is made, which can be used to determine which booking in the queue that the match references since the indices of ‘pot_times’ is the same as the indices of the extracted query. Once the list ‘cap_times’ is determined, the function is able to calculate the appropriate start and end times for the two users to meet; this is equal to the first and last entries of cap_times, respectively, since cap_times stores the intersection of the time ranges of the users that made each booking.

A non-trivial match is a match such that 1) the intersection of potential times is greater than or equal to 30 minutes (so that meeting times are longer than or equal to 30 minutes)  2) the intersection is not empty 3) the dates corresponding to each booking are the same (so that two bookings on different dates but same times do not get matched) 4) the users who made each booking are different (so that a user is not matched with themselves) and 5) the two bookings are non-identical (so that a booking does not match with the same booking). Criteria 2 through 5 must be satisfied so that the function behaves as intended. In criteria 1, we made the design choice of only allowing meetings to be longer than or equal to 30 minutes. This consideration is motivated by our decision that meals should not be less than 30 minutes as this would be too short of a meal. 

After the match is found and the times are calculated, the function updates the ‘queue’ table in meet_n_eat.db to reflect the match. Since each entry in ‘queue’ contains information about who initiated the bookings for each entry as the id number of the user in the ‘users’ table, by obtaining the ‘q_id’ for the entries that are matched (explained above) the function is able to determine the two users in the match. Since the user id is a foreign key referencing the primary key of users, the function is able to use this information to obtain the names and emails of each user in the match. The algorithm updates entries in the queue that have been matched so that their status is ‘MATCHED’ and they do not get “re-matched,” and also adds information about the user and booking to which the entry has been matched with. After doing so, the algorithm sends an automatic message to the users (using information in the ‘users’ table) notifying them that the match has been made. 

Implementation of the Cancel Algorithm

The cancel algorithm cancels any bookings, regardless of being ‘PENDING’ or ‘MATCHED,’ and removes them from the SQL table ‘queue’ in meet_n_eat.db. After doing so, if the status of the booking was ‘MATCHED,’ then the function sends an automated email to both users in the meeting notifying them that the meeting has been cancelled.
	
Suppose that the booking that the user wishes to cancel has status ‘PENDING,’ that is, the booking has not been matched with another booking yet. Then, the function simply queries the table ‘queue’ to delete the particular booking, identifying which booking to delete by using its q_id which is fed into the function as an argument.

Now suppose that the booking that the user wishes to cancel has status ‘MATCHED,’ that is, the booking has already been matched with another booking. Since each entry in “queue,” when matched, stores information about the other entry in the queue that it has been matched with as “match” (i.e. stores the primary key of the booking that it has been matched with), the function is able to determine which two entries it must delete from “queue” and runs a SQL query which does so. After the entries are successfully deleted, the function sends an automated email to both users notifying them that the meeting has been cancelled, with information including the user who cancelled the booking, the time which the booking was originally planned for, and the partner with whom each user was matched to. Since each entry in ‘queue’ that is matched with another entry includes information about both users in the match, the function is able to determine the information required in the email by referencing the respective key in the entry of “queue” (the entry with primary key equivalent to the value fed into the function as an argument). 

We designed the cancel algorithm such that it sends an email to both users in the match if an already matched booking is cancelled, whereas it does not send an email if the user cancels a pending booking. We decided to make the cancel function send an email to both users if a matched booking is cancelled based on the fact that we need a method to notify the user who did not cancel the matched booking that their meeting was cancelled by their partner (for example, if user1 and user2 are matched and user1 cancels the meeting, there needs to be a way for user2 to know that it was cancelled). We decided to not send an email when the user cancels a pending booking, as there is no need to notify the user since they are initiating the cancellation themselves, and because it is annoying if the user accidentally signed up for a meal and has to receive an email when they cancel the accidental booking. 


15 Minute Increments
	
Most data about a range of times is stored in increments of 15 minutes in our program; for instance, a range of 7:00 a.m. to 7:45 a.m. will be stored as a set with elements 7:00 a.m., 7:15 a.m., 7:30 a.m., and 7:45 a.m.. This design choice was made so we could simplify the implementation of the match algorithm when finding intersections between two time ranges. In order to account for this, all times that can be selected when specifying available times in “/hours” are in 15 minute increments. Although this limits the user’s flexibility to choose whichever time they want (for instance, 7:40 a.m.), the choice of 15 minute intervals minimizes this tradeoff since 15 minute increments are standardly used in the world to schedule events. 
